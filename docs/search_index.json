[["index.html", "Financial Econometrics - Tutorials About", " Financial Econometrics - Tutorials Alessandro Ciancetta Last update: January 16, 2025 About TA materials for the Financial Econometrics course held by Prof. Christian Brownlees at the Barcelona School of Economics. "],["session01.html", "Session 1 Introduction to time series 1.1 Stochastic processes and dependence 1.2 Asymptotic results 1.3 Empirical moments and summary statistics 1.4 Hypothesis testing", " Session 1 Introduction to time series 1.1 Stochastic processes and dependence Stochastic processes are a tool for modeling dependence in consecutive random variables \\(\\{\\dots, Y_{-2}, Y_{-1}, Y_{0}, Y_{1}, Y_{2} \\dots\\}\\). However, in practice, when we observe an empirical time series we are considering one, truncated realization of the stochastic process, \\(\\{y_1, y_2, \\dots, y_T\\}\\). As it is easy to imagine, this can cause some issues in studying the properties of an empirical time series. First, because we can only study the finite dimensional distribution of the process. Second, because our task is to learn something about the process by knowing only one realization of it. To overcome this limitations we need assumptions. In particular, two common assumptions in time series analysis are, loosely speaking: stationarity: the observed values in the sequence come from the same distribution, so that it is possible to learn from the past observations and to generalize the results to the entire, infinite stochastic process ergodicity: values observed far away in time can be considered as independent, and hence if we have enough observations the empirical time series is representative of the entire distribution of the stochastic process Under these (or similar) assumptions, we can use the observations from a single empirical time series to learn the parameters of our models. Stationarity Consider the example in the plot below. If we had only observations laying between two changepoints we would not be able to retrieve the dynamics of the underlying process. For instance, if we observed a series ending before the first changepoint, we would have no information about the future realizations of the process. Indeed, future observations would come from different distributions that we could not learn from available information. ## Example 1: non-stationary process # simulation t_max &lt;- 500 y &lt;- rep(NA, t_max) for (t in 1:t_max) { if (t&lt;=100) { y[t] &lt;- rnorm(1, mean = 0, sd = 0.1) } if (t&gt;100 &amp; t&lt;=250) { y[t] &lt;- rnorm(1, mean = 0.5, sd = 0.1) } if (t&gt;250 &amp; t&lt;=400) { y[t] &lt;- rnorm(1, mean = 0, sd = 0.2) } if (t&gt;400 &amp; t&lt;=t_max) { y[t] &lt;- 0.01*(t-400) + rnorm(1, mean = -0.2, sd = 0.02) } } # plot plot.ts(y, main = &quot;Non-stationary process&quot;, xaxt = &quot;n&quot;) abline(v = c(100, 250, 400), lty = 2) axis(1, at=c(100, 250, 400), labels = c(&quot;Changepoint 1&quot;, &quot;Changepoint 2&quot;, &quot;Changepoint 3&quot;)) Ergodicity Let \\(\\{z_t\\}_{t = 1}^{T} \\stackrel{iid}{\\sim} \\mathcal{N}(0, 1)\\). Consider the two following data-generating processes: \\[ \\begin{aligned} y_t &amp;= U_0 + 0.25z_t, \\quad \\text{with } U_0 \\sim \\mathcal{N}(0, 100) \\\\[1ex] x_t &amp;= z_t + z_{t-1} \\end{aligned} \\] We have: \\[ \\begin{aligned} \\mathbb{E}[y_t] &amp;= \\mathbb{E}[x_t] = 0 \\\\[1em] \\text{cov}(y_t, y_{t-k}) &amp;= \\begin{cases} 100+0.25^2 &amp; k = 0 \\\\ 100 &amp; k \\neq 0 \\end{cases} \\\\[1ex] \\text{cov}(x_t, x_{t-k}) &amp;= \\begin{cases} 2 &amp; k = 0 \\\\ 1 &amp; k = 1 \\\\ 0 &amp; k \\geq 2 \\end{cases} \\end{aligned} \\] We now simulate the two data generating processes in R. We want to draw many sequences \\(\\{y_1, \\dots, y_T\\}^{(s)}, \\{x_1, \\dots, x_T\\}^{(s)}\\) for \\(s = 1, \\dots, S\\) simulations to assess whether observing a single time series is enough to estimate the mean of the processes. ## Example 2: weak dependence ## Simulate process y_t # initialize TxS matrix to store result # (each column is a simulated time series {y_1, ..., y_T}^(s) ) nsim &lt;- 3 y_list &lt;- matrix(rep(NA, nsim*t_max), nrow = t_max, ncol = nsim) # simulation for (sim in 1:nsim) { set.seed(sim+123) U0 &lt;- rnorm(1, sd = 10) z &lt;- rnorm(t_max) y_list[,sim] &lt;- U0 + 0.25*z } As the plot below shows, if we observe a single simulated time series we cannot correctly estimate the mean of the process \\(\\mathbb{E}[y_t]\\) using the sample mean \\(\\bar{y}_T\\). What the sample mean is actually estimating in this case is the conditional expctation of \\(y_t\\) given the specific draw of the random intercept \\(U_0\\) in simulation \\(s\\): \\(\\mathbb{E}\\left[y_t | U_0 = U_0^{(s)}\\right] = U_0^{(s)}\\). Notice that in this case, if we observe a new point for stochastic process \\(y_t\\) (green points in the plot) we are likely not able to forecast it correctly based on the previous observations of a single time series. # plot plot.ts(y_list[,1], ylim = c(-25, 25), main = &quot;Realizations of non-ergodic series&quot;, ylab = &quot;y&quot;) lines(y_list[,2], col = &quot;steelblue&quot;) lines(y_list[,3], col = &quot;tomato&quot;) for (point in 1:100){ points(x = 501, rnorm(1, 0, 10)+rnorm(1, 0, 1), col = &quot;darkgreen&quot;, pch = 4) } abline(h = 0, col = &quot;black&quot;, lwd = 2, lty = 2) We now turn to process \\(x_t\\). ## Simulate process x_t # initialize object to store result nsim &lt;- 10000 x_list &lt;- matrix(rep(NA, nsim*t_max), nrow = t_max, ncol = nsim) # simulation for (sim in 1:nsim) { set.seed(sim+123) z &lt;- rnorm(t_max+1) x_list[,sim] &lt;- z[2:(t_max+1)] + z[1:t_max] } All the simulated time series have mean zero in this case. As a consequence, we can use the sample mean \\(\\bar{x}_T\\) obtained from a single time series to estimate the (unconditional) mean of the process \\(\\mathbb{E}[x_t]\\). # plot plot.ts(x_list[,1], ylim = c(min(x_list), max(x_list)), main = &quot;Realizations of ergodic series&quot;, ylab = &quot;x&quot;) lines(x_list[,2], col = &quot;steelblue&quot;) lines(x_list[,3], col = &quot;tomato&quot;) abline(h = 0, col = &quot;black&quot;, lwd = 2, lty = 2) 1.2 Asymptotic results The problem with the series \\(\\{y_t\\}\\) in the previous example is that the autocovariance function does not decay as the lag order increases. Loosely speaking, the series gets stuck in the trajectory given by the initial draw of \\(U_0\\) and does not revert to the true mean of the stochastic process. The main consequence is that we cannot learn the mean of the process by taking the average of the observations in a single realized time series. It is true in general that some conditions on the rate of decay of the autocovariance are required to recover the mean of the process. For example, the Law of Large Numbers (LLN) guarantees that the sample mean converges in probability to the true mean under the assumption that the autocovariances are absolutely summable: \\[ \\sum_{k=0}^\\infty |\\gamma_k| &lt; \\infty \\] Notice that in the case of \\(\\{y_t\\}\\) above instead \\(\\sum_{k=0}^\\infty |\\gamma_k| = \\infty\\). On the contrary, \\(\\{x_t\\}\\) satisfies both the conditions of the LLN and of the Central Limit Theorem (CLT). The condition for the latter is that \\(\\{\\phi_k\\}_{k=0}^\\infty\\) is absolutely summable in \\(x_t = \\mu_x + \\sum_{k=0}^\\infty\\phi_k z_{t-k} = z_t + z_{t-1}\\), which is trivially verified. Therefore, since \\(\\mu_x = 0\\), \\[ \\sqrt{T} \\ \\bar{x}_T \\ \\xrightarrow{d} \\ \\mathcal{N}(0, \\sigma^2_{LR}), \\] with \\(\\sigma^2_{LR} = \\sum_{k=-\\infty}^\\infty \\gamma_k = \\text{Var}(x_t) + 2\\sum_{k=1}^\\infty \\gamma_k\\). ## Example 3: central limit theorem x_empirical &lt;- x_list[,9] x_means &lt;- colMeans(x_list) x_theory_variance &lt;- 4 # long run variance x_empir_variance &lt;- var(x_empirical) + 2*(cov(x_empirical[1:(t_max-1)], x_empirical[2:t_max])) rbind(empirical_variance = x_empir_variance, simulated_variance = var(x_means*sqrt(t_max)), theoretical_variance = x_theory_variance) ## [,1] ## empirical_variance 4.174614 ## simulated_variance 4.050667 ## theoretical_variance 4.000000 ## Plot empirical distribution VS. theoretical distribution hist(x_means*sqrt(t_max), breaks = 20, freq = FALSE, main = &quot;Distribution of the simulated means&quot;, xlab = expression(Simulated ~ means ~ rescaled ~ by ~ sqrt(T))) lines(density(x_means*sqrt(t_max)), lwd = 4, col = &quot;tomato&quot;) lines(density(rnorm(1e6, mean = 0, sd = sqrt(x_theory_variance))), lwd = 4, col = &quot;darkblue&quot;) 1.3 Empirical moments and summary statistics For this example we use the U.S. GDP data. x &lt;- read.csv(&quot;../data/us-gdp.csv&quot;)[,2] x &lt;- ts(x, start = c(1947, 1), frequency = 4) t_max &lt;- length(x) plot.ts(x, main = &quot;U.S. GDP&quot;, ylab = &quot;Billions of dollars&quot;) Consider the annualized quarterly growth rates: # xgrowth &lt;- ( (x[2:t_max]/x[1:(t_max-1)])^4 - 1 )*100 xgrowth &lt;- 4*diff(log(x))*100 xgrowth &lt;- ts(xgrowth, start = c(1947, 2), frequency = 4) plot.ts(xgrowth, main = &quot;Annualized GDP growth&quot;) Below we compute some summary statistics for the time series of the U.S. GDP growth rates. ## Example 4: empirical moments and summary statistics of the GDP growth library(moments) rbind( mean = mean(xgrowth), variance = var(xgrowth), skewness = skewness(xgrowth), kurtosis = kurtosis(xgrowth), min = min(xgrowth), max = max(xgrowth), above_5 = mean(xgrowth &gt; 5), annualized_volatility = sqrt(4)*sd(xgrowth) ) ## [,1] ## mean 6.1858847 ## variance 26.5117326 ## skewness -0.9793909 ## kurtosis 17.9597257 ## min -34.4929551 ## max 33.4065902 ## above_5 0.6078431 ## annualized_volatility 10.2979090 ## Autocovariance function gamma &lt;- function(x, k) { k &lt;- abs(k) t_max &lt;- length(x) # (t_max-k)/t_max * cov(x[1:(length(x)-k)], x[(k+1):length(x)]) # for compatibility with acf() cov(x[1:(t_max-k)], x[(k+1):t_max]) } ## Autocorrelation rho &lt;- function(x, k) {gamma(x, k) / gamma(x, 0)} ## autocorrelation at different lags sapply(0:12, rho, x = xgrowth) ## [1] 1.000000000 0.262228567 0.254514380 0.097922439 0.030475252 ## [6] -0.016390183 -0.003186283 0.054980002 0.062358818 0.146571003 ## [11] 0.169620140 0.143289793 0.096325249 Under the null hypothesis \\(H_0: \\rho = 0\\), the sample autocorrelation is distributed as \\[ \\sqrt{T} \\ \\hat{\\rho} \\xrightarrow{d} \\mathcal{N}(0, 1) \\] This means that the asymptotic variance of the estimator under the null is \\(1/T\\). The plot reports the 95% confidence interval obtained as \\(\\left(0 \\pm \\frac{z_{0.975}}{\\sqrt{T}}\\right)\\). ## confidence interval qnorm(0.975)*(1/sqrt(t_max)) ## [1] 0.1118611 ## using built-in function for the autocorrelogram acf(xgrowth, lag.max = 16) ## partial autocorrelation function pacf(xgrowth, lag.max = 16) 1.4 Hypothesis testing In this section we use three testing procedures on the GDP growth data: the Augmented Dickey-Fuller test for stationarity, the Jarque-Bera test for normality and the t-test for the mean of a process. ## Example 5: tests on GDP growth rates library(tseries) ## stationarity: augmented Dickey-Fuller adf.test(x) ## ## Augmented Dickey-Fuller Test ## ## data: x ## Dickey-Fuller = 2.4611, Lag order = 6, p-value = 0.99 ## alternative hypothesis: stationary adf.test(xgrowth) ## ## Augmented Dickey-Fuller Test ## ## data: xgrowth ## Dickey-Fuller = -5.9064, Lag order = 6, p-value = 0.01 ## alternative hypothesis: stationary ## normality: Jarque-Bera jarque.bera.test(xgrowth) ## ## Jarque Bera Test ## ## data: xgrowth ## X-squared = 2902.3, df = 2, p-value &lt; 2.2e-16 ## mean zero: t-test sigmaLR &lt;- sum(sapply(-100:100, gamma, x = xgrowth)) t_stat &lt;- mean(xgrowth)/(sqrt(sigmaLR/t_max)) p_value &lt;- (1-pnorm(abs(t_stat)))*2 # plot(density(rnorm(1e6)), xlim = c(-8, 8)) # abline(v = t_stat, col = &quot;tomato&quot;, lwd = 2) # compare with unadjusted variance # t.test(xgrowth, mu = 0) # mean(xgrowth)/(sqrt((t_max/(t_max-1))*var(xgrowth)/t_max)) # for compatibility with t-test() t_stat_unadjasted &lt;- mean(xgrowth)/(sqrt(var(xgrowth)/t_max)) p_value_unadjasted &lt;- (1-pnorm(abs(t_stat_unadjasted)))*2 rbind(p_value_unadjasted = p_value_unadjasted, p_value = p_value) ## [,1] ## p_value_unadjasted 0.000000e+00 ## p_value 4.884981e-15 # We can study when does the adjustment really matters # using the results of the previous Monte Carlo simulation ## Get variance and long-run variance sigma &lt;- apply(x_list, 2, function(x) sqrt(gamma(x, k = 0)/length(x))) sigmaLR &lt;- apply(x_list, 2, function(x) sqrt(sum(sapply(-3:3, gamma, x = x))/length(x))) ## Get adjusted and unadjusted t-statistics t_stat_unadjasted &lt;- x_means/sigma t_stat &lt;- x_means/sigmaLR ## Compute percentage of type-1 errors in the simulation type1error &lt;- mean(abs(t_stat) &gt; qnorm(0.975)) type1error_unadjusted &lt;- mean(abs(t_stat_unadjasted) &gt; qnorm(0.975)) rbind( type1error = type1error, type1error_unadjusted = type1error_unadjusted ) ## [,1] ## type1error 0.0569 ## type1error_unadjusted 0.1716 ## plot distributions of adjusted and unadjusted t-statistics hist(t_stat_unadjasted, breaks = 100, freq = FALSE, col = &quot;tomato&quot;, ylim = c(0, 0.45), xlim = c(-5, 6), xlab = &quot;t-stat&quot;, main = &quot;Distribution of the t-statistic in Monte Carlo simulation&quot;) hist(t_stat, breaks = 100, freq = FALSE, add = TRUE, col = &quot;lightgreen&quot;) lines(density(rnorm(1e6, mean = 0, sd = 1)), lwd = 4, col = &quot;black&quot;) legend(&quot;topright&quot;, c(&quot;Unadjusted&quot;, &quot;Adjusted&quot;), col=c(&quot;tomato&quot;, &quot;lightgreen&quot;), lwd=6) abline(v = qnorm(c(0.025, 0.975)), lty = 2, lwd = 2) text(x=c(6.5, 6.5), y=c(0.3, 0.25), labels=c(paste0(&quot;Type 1 error: &quot;, round(type1error_unadjusted*100, 1), &quot;%&quot;), paste0(&quot;Type 1 error adjusted: &quot;, round(type1error*100, 1), &quot;%&quot;)), col=c(&quot;tomato&quot;, &quot;lightgreen&quot;), pos = 2) "],["session02.html", "Session 2 Forecasting with time-series regression 2.1 Oracle inequality 2.2 Application: forecasting unemployment", " Session 2 Forecasting with time-series regression This session covers a first introduction to forecasting the conditional mean of a time series. A forecasting procedure involves three main objects: A set of predictors and a target variable that we want to forecast A class of forecasting models that we consider A loss function to evaluate the accuracy of the forecasts In this session we focus on the class of linear regression models estimated via least-squares. The loss function that we consider throughout this chapter is the quadratic loss function estimated using the Mean Squared Error (MSE) defined in the R function below. ## Function to compute the MSE. y = true value, f = forecast mse &lt;- function(y, f) {mean((y-f)^2)} The first section presents a simulation exercise to show the finite-sample properties of the linear regression model under mis-specification. The second section is an empirical application to the problem of forecasting the U.S. unemployment rate using some relevant macroeconomic indicators. 2.1 Oracle inequality Optional section, not covered in class Given a forecasting problem, the optimal prediction rule is defined as the one that minimizes the theoretical risk: \\[ f_{t+h|t}^* = \\arg\\min_{f \\in \\mathcal{F}} R(f_{t+h|t}) \\] and the associated optimal risk is denoted by \\(R^*\\). Under the square loss function, the optimal rule is the conditional expectation: \\[ f_{t+h|t}^* = \\mathbb{E}[y_{t+h}| x_t] \\] Notice that the exact functional form of the predictor is unknown: the conditional expected value could be of any linear or non-linear form. To make the theory of learning operational, we then have to restrict our attention to a class of prediction rules and pick the best rule from that class according to the limited amount of data available. A commonly used class of predictors is that of the linear predictors. Consider a linear regression model for predicting the target variable \\(y_{t+h}\\): \\[ f_{t+h|t} = x_t&#39;\\theta. \\] where \\(f_{t+h|t}\\) denotes the \\(h\\)-periods-ahead forecast. Irrespective of what is the true d.g.p., \\(\\theta\\) is the parameter that leads to the best forecasts within the class of linear regression models \\[ \\theta = \\arg\\min_{\\tilde{\\theta} \\in \\mathbb{R}^p} \\mathbb{E}[L(y_{t+h}, f_{t+h|t}(\\theta))] = R(\\theta) \\] However, in practice we can only use a finite sample to learn the parameters of the linear model via empirical risk minimization: \\[ \\hat{\\theta} = \\arg\\min_{\\theta \\in \\mathbb{R}^p} R_T(\\theta) \\] In our case, \\(R_T(\\theta) = \\frac{1}{T-h-t_w+1}\\sum_{t=t_w}^{T-h} (y_{t+h} - f_{t+h|t})^2 = MSE\\), where \\(t_w\\) denotes the initial number of observations used to train the model. So far, we have introduced three different measures of risk: \\(R^*\\), the risk associated with the theoretical optimal predictor if the true d.g.p. were known \\(R(\\theta)\\), the risk associated with the optimal predictor within the parametric class considered for learning \\(R_T(\\hat\\theta)\\), the empirical risk obtained by minimization of the loss function using the available data sample The regret (i.e. the difference between the optimal and the empirical risk) can be expressed in a way that links these three quantities: \\[ R_T(\\hat\\theta) - R^* = \\underbrace{\\left[ R(\\theta) - R^* \\right]}_{_{\\text{Approximation error}}} + \\underbrace{\\left[R_T(\\hat\\theta) - R(\\theta)\\right]}_{\\text{Estimation error}} \\] We mainly focus on the estimation error. In particular, we are usually interested in establishing finite-sample, probabilistic bounds to this quantity. These bounds are helpful in assessing, for instance, how many observations a model needs to perform well and how its performance relates to the number of predictors. For linear prediction, the following oracle inequality holds: there exists a constant \\(c\\) such that \\[ R(\\hat\\theta) \\leq R(\\theta) + c \\frac{p}{T}, \\quad \\text{w.p. } 1-1/T \\] The example below shows that the inequality holds in a simulation setting. We generate \\(10^6\\) observations from the following process: \\[ y_t = 0.6\\times y_{t-1} - \\tanh(0.3 \\times y_{t-1}) + 0.8\\times x_{1,t-1} + 0.2 \\times x_{2,t-1} - 0.7\\times x_{3,t-1} + \\varepsilon_t, \\] where \\(\\varepsilon_t \\sim \\mathcal{N}(0, 0.5)\\) and the variables \\(x_{1,t}, x_{2,t}, x_{3,t}\\) are drawn independently from a standard normal distribution. We then consider the class of linear regression models, \\[ y_t = \\beta_0 + \\beta_1 y_{t-1} + \\beta_2 x_{1,t-1} + \\beta_3 x_{2,t-1} + \\beta_3 x_{3,t-1} + u_t \\] Notice that the OLS estimator is the empirical risk minimizer in the case of a square loss. In the simulation setting, we can also obtain \\(R(\\theta)\\) by estimating the parameters of the regression using the entire simulated population. We can then draw many estimates of \\(R(\\hat\\theta)\\) by considering different subsamples of the simulated population and estimating the parameters of the model using OLS on the subsample. By doing so, we can simulate the distribution of the empirical risk and compare it against the overall minimum risk within the class of linear estimators to assess the oracle inequality. We repeat the exercise considering different sizes of the subsamples to show that the bound gets tighter as the sample size increases, as it must be for the inequality to have the oracle property. ## Example 1: simulation for oracle inequality # build the simulated population dataset N &lt;- 3 T_pop &lt;- 1e5 set.seed(455) x_pop &lt;- matrix(rnorm((T_pop+1)*N), ncol = N) y_pop &lt;- rep(0, T_pop) for (t in 2:(T_pop+1)) { set.seed(456*t) # non-linear d.g.p. y_pop[t] &lt;- 0.6*y_pop[t-1] - tanh(0.3*y_pop[t-1]) + 0.8*x_pop[t-1, 1] + 0.2*x_pop[t-1, 2] - 0.7*x_pop[t-1, 3] + rnorm(1, sd = 0.5) } colnames(x_pop) &lt;- paste0(&quot;x&quot;, 1:N) # target is y(t+1). predictor is x(t) d_pop &lt;- as.data.frame(cbind(y = y_pop[2:(T_pop+1)] , x_pop[1:T_pop,] )) # estimate the linear predictor y(t) = x(t-1)&#39;b via OLS model_pop &lt;- lm(y ~ x1 + x2 + x3, data = d_pop) summary(model_pop) ## estimate the optimal risk and the population risk within the linear family # optimal f_optimal &lt;- rep(NA, T_pop+1) for (t in 1:T_pop) { f_optimal[t+1] &lt;- 0.6*y_pop[t] - tanh(0.3*y_pop[t]) + 0.8*x_pop[t, 1] + 0.2*x_pop[t, 2] - 0.7*x_pop[t, 3] } f_optimal &lt;- f_optimal[-1] risk_star &lt;- mse(d_pop[,1], f_optimal) # linear family risk_pop &lt;- mse(d_pop[,1], predict(model_pop)) ## Run the simulations to estimate a small-sample model many times t_small &lt;- 30 t_medium &lt;- 300 t_large &lt;- 3000 nsim &lt;- 1000 empirical_risk &lt;- list( model_small = rep(NA, nsim), model_medium = rep(NA, nsim), model_large = rep(NA, nsim) ) for (s in 1:nsim) { set.seed(456*s) # pick index at random between 1e5 and 9e5 idx &lt;- sample(1:(T_pop-t_large), 1) # consider the t subsequent observations d_small &lt;- d_pop[idx:(idx+t_small), ] d_medium &lt;- d_pop[idx:(idx+t_medium),] d_large &lt;- d_pop[idx:(idx+t_large), ] # estimate the model model_small &lt;- lm(y ~ x1 + x2 + x3, data = d_small) model_medium &lt;- lm(y ~ x1 + x2 + x3, data = d_medium) model_large &lt;- lm(y ~ x1 + x2 + x3, data = d_large) # compute the MSE and store the results empirical_risk$model_small[s] &lt;- mse(d_small[,1], predict(model_small)) empirical_risk$model_medium[s] &lt;- mse(d_medium[,1], predict(model_medium)) empirical_risk$model_large[s] &lt;- mse(d_large[,1], predict(model_large)) } # compute the constant C s.t. the bound risk_pop + C(P/t) is satisfied # 1-1/t fraction of times c_small &lt;- quantile(empirical_risk$model_small, 1-1/t_small) c_medium &lt;- quantile(empirical_risk$model_medium, 1-1/t_medium) c_large &lt;- quantile(empirical_risk$model_large, 1-1/t_large) ## report the distribution of the simulated empirical risks par(mfrow = c(2,2)) # small hist(empirical_risk$model_small, xlab = &quot;Empirical risk&quot;, main = &quot;Small model&quot;) abline(v = c_small, lwd = 2, lty = 2) abline(v = risk_pop, lwd = 3, lty = 1, col = &quot;darkred&quot;) text(x = c_small*1.2, y = 250, labels = paste0(&quot;Estimation error\\nbound: &quot;, round(c_small*N/t_small,3))) # medium hist(empirical_risk$model_medium, xlab = &quot;Empirical risk&quot;, main = &quot;Medium model&quot;) abline(v = c_medium, lwd = 2, lty = 2) abline(v = risk_pop, lwd = 3, lty = 1, col = &quot;darkred&quot;) text(x = c_medium*0.98, y = 150, labels = paste0(&quot;Estimation error\\nbound: &quot;, round(c_medium*N/t_medium,3))) # large hist(empirical_risk$model_large, xlab = &quot;Empirical risk&quot;, main = &quot;Large model&quot;) abline(v = c_large, lwd = 2, lty = 2) abline(v = risk_pop, lwd = 3, lty = 1, col = &quot;darkred&quot;) text(x = c_large*0.98, y = 120, labels = paste0(&quot;Estimation error\\nbound: &quot;, round(c_large*N/t_large,3))) 2.2 Application: forecasting unemployment library(sandwich) # for estimation of robust standard errors library(lmtest) # for coeftest library(forecast) # for dm.test We now consider an empirical application using the U.S. data from the FRED-MD dataset, a collection of 127 macroeconomic time series observed at a monthly frequency. To make sure that the series in the model are stationary, we transform the variables according to the recommendation of the authors, as summarised in the transformation code tcode in the first row of the dataset: tcode Transformation 1 No 2 \\(\\Delta x_t\\) 3 \\(\\Delta^2 x_t\\) 4 \\(\\log(x_t)\\) 5 \\(\\Delta\\log(x_t)\\) 6 \\(\\Delta^2\\log(x_t)\\) 7 \\(\\Delta\\left(\\frac{x_t}{x_{t-1}} -1 \\right)\\) ## load FRED-MD data fredmd &lt;- read.csv(&quot;../data/current.csv&quot;) dates &lt;- as.Date(fredmd$sasdate[-1],&#39;%m/%d/%Y&#39;) tcodes &lt;- fredmd[1,-1] d &lt;- fredmd[-1,-1] # subset 1980-2024 period data &lt;- d[dates &gt;= &#39;1980-01-01&#39;, ] dates &lt;- dates[dates &gt;= &#39;1980-01-01&#39;] t_max &lt;- length(dates) # choose variables target &lt;- &quot;UNRATE&quot; predictors &lt;- c(&#39;S.P.500&#39;,&#39;HOUST&#39;,&#39;UMCSENTx&#39;) vars &lt;- c(target, predictors) data &lt;- data[, vars] tcodes &lt;- tcodes[, vars] ## list of functions for transformation transform_fredmd &lt;- list( function(x) x, function(x) c(0, diff(x)), function(x) c(0, 0, diff(x, differences = 2)), function(x) log(x), function(x) c(0, diff(log(x))), function(x) c(0, 0, diff(log(x), differences = 2)), function(x) c(0, 0, diff( x[2:length(x)]/x[1:(length(x)-1)] - 1)) ) ## save the transformed series separately unrate &lt;- transform_fredmd[[tcodes$UNRATE]](data$UNRATE) sp500 &lt;- transform_fredmd[[tcodes$S.P.500]](data$S.P.500) house &lt;- transform_fredmd[[tcodes$HOUST]](data$HOUST) sent &lt;- transform_fredmd[[tcodes$UMCSENTx]](data$UMCSENTx) # plot par(mfrow = c(2,2)) plot.ts(ts(unrate, start = c(1980, 1), freq = 12), main = &quot;UNRATE&quot;, ylab = &quot;Month-on-month change&quot;) plot.ts(ts(sp500, start = c(1980, 1), freq = 12), main = &quot;S.P.500&quot;, ylab = &quot;Monthly % variation&quot;) plot.ts(ts(house, start = c(1980, 1), freq = 12), main = &quot;HOUST&quot;, ylab = &quot;log(housing starts)&quot;) plot.ts(ts(sent, start = c(1980, 1), freq = 12), main = &quot;UMCSENTx&quot;, ylab = &quot;Month-on-month change&quot;) We can have a look to the autocorrelation properties of the series. ## ACF plot par(mfrow = c(2,2)) acf(unrate, ylim=c(-0.1,1), lwd=5, xlim=c(0,25), main=&#39;UNRATE&#39;) acf(sp500, ylim=c(-0.1,1), lwd=5, xlim=c(0,25), main=&#39;S.P.500&#39;) acf(house, ylim=c(-0.1,1), lwd=5, xlim=c(0,25), main=&#39;HOUST&#39;) acf(sent, ylim=c(-0.1,1), lwd=5, xlim=c(0,25), main=&#39;UMCSENTx&#39;) We now study some in-sample properties of the predictive regression: \\[ \\begin{aligned} \\text{UNRATE}_t &amp;= \\beta_0 + \\beta_1 \\ \\text{UNRATE}_{t-1} + \\beta_2 \\ \\text{HOUST}_{t-1} \\ + \\beta_3 \\ \\text{SP500}_{t-1} \\ + \\beta_4 \\ \\text{SENT}_{t-1} \\ +\\\\ &amp;+ \\ \\text{dummies} \\ + \\varepsilon_t. \\end{aligned} \\] In particular, we compute the in-sample predictive fit of the model and we study the properties of the residuals. ## Fit predictive regression # Create the dataframe for regression data_regression &lt;- data.frame( unrate = unrate[2:t_max], unrate_lag = unrate[1:(t_max-1)], house = house[1:(t_max-1)], sp500 = sp500[1:(t_max-1)], sent = sent[1:(t_max-1)], d1 = (dates[2:t_max]==&quot;2020-04-01&quot;)*1, # covid dummy variable d2 = (dates[2:t_max]==&quot;2020-05-01&quot;)*1, d3 = (dates[2:t_max]==&quot;2020-06-01&quot;)*1, d4 = (dates[2:t_max]==&quot;2020-07-01&quot;)*1, d5 = (dates[2:t_max]==&quot;2020-08-01&quot;)*1, d6 = (dates[2:t_max]==&quot;2020-09-01&quot;)*1 ) # Fit OLS pred_model &lt;- lm(unrate ~ ., data = data_regression) vcov_nw &lt;- NeweyWest(pred_model, prewhite=F) # BAD inference (unadjusted asymptotic variance) coeftest(pred_model) ## ## t test of coefficients: ## ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.6066299 0.1752768 3.4610 0.0005829 *** ## unrate_lag 0.1241838 0.0445711 2.7862 0.0055298 ** ## house -0.0854805 0.0244385 -3.4978 0.0005097 *** ## sp500 -0.4989494 0.2318030 -2.1525 0.0318242 * ## sent -0.0021749 0.0020826 -1.0443 0.2968167 ## d1 10.0608718 0.1859894 54.0938 &lt; 2.2e-16 *** ## d2 -2.8193347 0.4924891 -5.7247 1.762e-08 *** ## d3 -1.9965983 0.1882808 -10.6044 &lt; 2.2e-16 *** ## d4 -0.4795102 0.2010676 -2.3848 0.0174483 * ## d5 -1.6764097 0.1795464 -9.3369 &lt; 2.2e-16 *** ## d6 -0.2339512 0.1927566 -1.2137 0.2254137 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 # Inference using the Newey West estimator coeftest(pred_model, vcov_nw) ## ## t test of coefficients: ## ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.6066299 0.3400340 1.7840 0.07501 . ## unrate_lag 0.1241838 0.0686069 1.8101 0.07087 . ## house -0.0854805 0.0464922 -1.8386 0.06655 . ## sp500 -0.4989494 0.2553605 -1.9539 0.05125 . ## sent -0.0021749 0.0024861 -0.8748 0.38207 ## d1 10.0608718 0.0970859 103.6286 &lt; 2.2e-16 *** ## d2 -2.8193347 0.7159484 -3.9379 9.351e-05 *** ## d3 -1.9965983 0.1022064 -19.5350 &lt; 2.2e-16 *** ## d4 -0.4795102 0.1528230 -3.1377 0.00180 ** ## d5 -1.6764097 0.0584554 -28.6785 &lt; 2.2e-16 *** ## d6 -0.2339512 0.1251049 -1.8700 0.06205 . ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 # True VS. predicted values plot.ts(data_regression$unrate, ylim = c(-0.8, 0.8), col = &quot;darkgrey&quot;) lines(predict(pred_model), col = &quot;darkred&quot;) # Analysis of residuals acf(pred_model$residuals, lwd = 5) # Test for autocorrelation Box.test(pred_model$residuals, lag=12) ## ## Box-Pierce test ## ## data: pred_model$residuals ## X-squared = 76.202, df = 12, p-value = 2.176e-11 We can assess the effect of an exogenous change in the predictors on the target variable over time by using the method of local projections. Here we show the effect of a positive shock in the S.P.500 index. ## Local projections for assessing the impact of a shock # set number of horizons and initialize objects H &lt;- 12 lp &lt;- rep(0,H) # local projection lp_confint &lt;- matrix(0,H,2) # confidence intervals # compute the impact after h = 1,...,H horizons for(h in 1:H){ # prepare dataset for forecasting h periods ahead data_h &lt;- cbind( data_regression[h:t_max, c(&quot;unrate&quot;, paste0(&quot;d&quot;, 1:6))], data_regression[1:(t_max-h+1), c(&quot;unrate_lag&quot;, &quot;house&quot;, &quot;sp500&quot;, &quot;sent&quot;)] ) # predict pred_model_h &lt;- lm(unrate ~ ., data = data_h) # compute Newey-West estimate vcov_nw_h &lt;- NeweyWest(pred_model_h, prewhite = F) # compute standard errors for the estimated coefficients confint_h &lt;- coeftest(pred_model_h, vcov_nw_h) # store the estimates and the 90% confidence intervals lp[h] &lt;- confint_h[&#39;sp500&#39;,&#39;Estimate&#39;] lp_confint[h, ] &lt;- lp[h] + confint_h[&#39;sp500&#39;,&#39;Std. Error&#39;]*c(-1,1)*qnorm(0.05) } ## Plot the impulse response function plot(1:H, lp, lwd = 3, col = &#39;darkred&#39;, t = &quot;b&quot;, ylim = c(-2,1), main = &quot;Response of unemployment after a positive shock on the S.P.500&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;) lines(lp_confint[,1], lwd = 1, col = &#39;darkred&#39;, t = &quot;b&quot;, pch = 25) lines(lp_confint[,2], lwd = 1, col = &#39;darkred&#39;, t = &quot;b&quot;, pch = 24) grid() box() abline(h=0,lwd=3) We now proceed to evaluate the forecasts of the model. To do so, we split the data into a training set (observations up to 1999:12) and a testing set (starting in 2000:01). We estimate the parameters of the model on the training data and then make predictions based on the value of the predictors and the estimated coefficients. We compare the forecasts against the sample mean using the MSE. The Diebold-Mariano test suggests that the regression method has a superior forecasting performance than the sample mean. However, this result depends on the specification of the regression model and the predictive ability of the model is still pretty poor. ## Forecast evaluation # split training set (1980-2000) and testing set (2000-2024) in_sample &lt;- (dates[2:t_max] &lt; as.Date(&#39;2000-01-01&#39;)) out_sample &lt;- (dates[2:t_max] &gt;= as.Date(&#39;2000-01-01&#39;) &amp; ( dates[2:t_max] &lt; as.Date(&#39;2020-03-01&#39;) | dates[2:t_max] &gt;= as.Date(&#39;2020-09-01&#39;) )) data_train &lt;- data_regression[in_sample,] data_test &lt;- data_regression[out_sample,] dates_test &lt;- (dates[2:t_max])[out_sample] # fit predictive models model1 &lt;- lm(unrate ~ unrate_lag + sp500 + sent + house, data = data_train) model2 &lt;- lm(unrate ~ unrate_lag + sp500 + sent, data = data_train) model3 &lt;- lm(unrate ~ unrate_lag + sp500, data = data_train) # get predictions y_hat1 &lt;- predict(model1, newdata = data_test) y_hat2 &lt;- predict(model2, newdata = data_test) y_hat3 &lt;- predict(model3, newdata = data_test) # compute benchmark prediction (sample mean) y_benchmark &lt;- rep(mean(data_train$unrate), sum(out_sample)) # compute MSE mse_model1 &lt;- mse(data_test$unrate, y_hat1) mse_model2 &lt;- mse(data_test$unrate, y_hat2) mse_model3 &lt;- mse(data_test$unrate, y_hat3) mse_benchmark &lt;- mse(data_test$unrate, y_benchmark) # results round(rbind( mse_4vars = mse_model1, mse_3vars = mse_model2, mse_2vars = mse_model3, mse_mean = mse_benchmark, R2_2vars = 1 - mse_model3/mse_benchmark ), 4) ## [,1] ## mse_4vars 0.0536 ## mse_3vars 0.0302 ## mse_2vars 0.0296 ## mse_mean 0.0318 ## R2_2vars 0.0677 # convert to ts object to have dates in plot y_true &lt;- ts(data_test$unrate, start = c(2000, 1), frequency = 12) y_hat3 &lt;- ts(y_hat3, start = c(2000, 1), frequency = 12) y_benchmark &lt;- ts(y_benchmark, start = c(2000, 1), frequency = 12) # plot plot.ts(y_true, col = &quot;darkgrey&quot;, ylim = c(-0.4, 0.2), main = &quot;Forecasted values of unemployment change&quot;, ylab = &quot;Change in unemployment rate&quot;, xlab = &quot;&quot;) lines(y_hat3, col = &quot;darkred&quot;, lwd = 2) lines(y_benchmark) rect(2020.25,-1,2020.75,1,col = rgb(0.6,0.1,0.1,1/4)) legend(&quot;bottomleft&quot;, c(&quot;Forecast&quot;, &quot;True&quot;), col=c(&quot;darkred&quot;, &quot;darkgrey&quot;), lwd=6) It is common to report the plot of the normalized cumulated squared errors to assess if one model has a superior forecasting ability over all the testing period: \\[ \\text{Cumulated error}_t = \\frac{\\sum_{\\tau = t_w + 1}^t e_\\tau^2}{\\sum_{\\tau = t_w + 1}^T \\bar{e}_{\\tau}^2} \\] where \\(e_\\tau, \\bar{e}_\\tau\\) denote respectively the forecast error of the model and the benchmark at time \\(\\tau\\), and \\(t_w\\) is the number of periods in the training set. ## Plot the forecast errors over time # compute the forecast errors err_model &lt;- y_true-y_hat3 err_benchmark &lt;- y_true-y_benchmark # compute the (normalized) cumulated squared errors and convert to ts object err2_model &lt;- ts(cumsum((err_model)^2), start = c(2000, 1), frequency = 12) err2_benchmark &lt;- ts(cumsum((err_benchmark)^2), start = c(2000, 1), frequency = 12) err2_constant &lt;- sum((y_true-y_benchmark)^2) # plot the cumulated squared errors over time plot.ts(err2_benchmark/err2_constant, lwd = 2, ylab = &quot;Cumulated squared errors&quot;, main = &quot;Forecast errors over time&quot;, xlab = &quot;&quot;) lines(err2_model/err2_constant, col = &quot;darkred&quot;, lwd = 2) rect(2020.25,-1,2020.75,1.5,col = rgb(0.6,0.1,0.1,1/4)) legend(&quot;topleft&quot;, c(&quot;Regression model&quot;, &quot;Sample mean&quot;), col=c(&quot;darkred&quot;, &quot;black&quot;), lwd=6) ## Diebold-Mariano test for predictive performance # one-sided test: # - H0: err_benchmark = err_model # - H1: err_benchmark &gt; err_model dm.test(err_benchmark, err_model, alternative = &quot;greater&quot;) ## ## Diebold-Mariano Test ## ## data: err_benchmarkerr_model ## DM = 2.4995, Forecast horizon = 1, Loss function power = 2, p-value = ## 0.006504 ## alternative hypothesis: greater "],["session03.html", "Session 3 Large-dimensional methods for forecasting 3.1 Preprocess FRED-MD 3.2 Forecasting algorithms 3.3 Forecast evaluation", " Session 3 Large-dimensional methods for forecasting In this session we compare the performances of four forecasting methods to predict the monthly change in the U.S. unemployment rate using more than 100 variables from the FRED-MD dataset. In order to deal with the large amount of data, we consider methods based on principal component analysis, penalized likelihood and regression trees. 3.1 Preprocess FRED-MD The preprocessing of the data is very similar to that of the previous session. The only difference is that we now transform all the series in the dataset using the list of transformation functions of the previous session. For simplicity, here we remove the columns with missing values. An alternative could be to impute the missing values using some regression technique. However, it is important to notice that in the latter case we should impute the missing values at each step of the forecast evaluation to make sure that no future information is included in the forecasts. ## load data fredmd &lt;- read.csv(&quot;../data/current.csv&quot;) dates &lt;- as.Date(fredmd$sasdate[-1],&#39;%m/%d/%Y&#39;) target_variables &lt;- c(&quot;UNRATE&quot;, &quot;W875RX1&quot;, &quot;GS10&quot;, &quot;CPIAUCSL&quot;, &quot;WPSFD49207&quot;, &quot;PAYEMS&quot;, &quot;HOUST&quot;, &quot;INDPRO&quot;, &quot;M2SL&quot;, &quot;S.P.500&quot;) ## get tcodes tcodes &lt;- fredmd[1,-1] d &lt;- fredmd[-1, -1] ## Transform variables # transformation functions transform_fredmd &lt;- list( function(x) x, function(x) c(0, diff(x)), function(x) c(0, 0, diff(x, differences = 2)), function(x) log(x), function(x) c(0, diff(log(x))), function(x) c(0, 0, diff(log(x), differences = 2)), function(x) c(0, 0, diff( x[2:length(x)]/x[1:(length(x)-1)] - 1)) ) # transform series one by one for (j in 1:ncol(d)) { tcode &lt;- tcodes[[j]] d[,j] &lt;- transform_fredmd[[tcode]](d[,j]) } ## Subset and remove columns with NAs d &lt;- d[dates &gt;= &#39;1980-01-01&#39;, ] dates &lt;- dates[dates &gt;= &#39;1980-01-01&#39;] idx_na &lt;- (colSums(is.na(d))==0) d &lt;- d[, idx_na] plot.ts(d[,target_variables]) 3.2 Forecasting algorithms Below we define the forecasting algorithms that we use in the forecast evaluation. Notice that at each step of the forecast evaluation we rescale the data so that each variable has mean zero and unit variance. This step is very important for many machine learning algorithms. If the variables have a different magnitude, the optimization procedure involved tend to over-focus on the features with higher magnitude, while we want to exploit the variability of each feature irrespectively of its scale. Also, we do not explicitly account for outliers in the forecasting algorithms, and we simply discard the Covid period during the evaluation of the results. In this sense, the procedure will tend to benefit those methods that can automatically deal better with the presence of outliers in the data used for estimation. ## Principal Component Regression (PCR) pcr &lt;- function(d, target, n_components, horizon) { ## Scale the data d_scaled &lt;- scale(d) d_mean &lt;- attr(d_scaled, &quot;scaled:center&quot;) d_sd &lt;- attr(d_scaled, &quot;scaled:scale&quot;) ## get the target target_idx &lt;- which(colnames(d) == target) y &lt;- d_scaled[,target_idx] ## get the principal components of the other variables x &lt;- d_scaled[,-target_idx] eigen_list &lt;- prcomp(x, center=FALSE) f &lt;- eigen_list$x[,1:n_components] ## define the dataframes t_max &lt;- length(y) d_pcr &lt;- as.data.frame(cbind( y = y[(horizon+1):t_max], y_lag = y[1:(t_max-horizon)], f[1:(t_max-horizon),]) ) ## fit model &lt;- lm(y ~ ., data = d_pcr) ## forecast pred &lt;- predict(model, newdata = d_pcr[nrow(d_pcr), ]) ## output pred*d_sd[target] + d_mean[target] } # pcr(d, &quot;INDPRO&quot;, 4, 1) ## Penalized regression: LASSO (alpha = 1) and ridge (alpha = 0) library(glmnet) ## Caricamento del pacchetto richiesto: Matrix ## Loaded glmnet 4.1-4 penalized_reg &lt;- function(d, target, horizon, alpha = 1, nlambda = 100) { ## Scale the data d_scaled &lt;- scale(d) d_mean &lt;- attr(d_scaled, &quot;scaled:center&quot;) d_sd &lt;- attr(d_scaled, &quot;scaled:scale&quot;) ## get the target and predictors t_max &lt;- nrow(d) y &lt;- d_scaled[(horizon+1):t_max, target] x &lt;- d_scaled[1:(t_max-horizon), ] # include also lagged target variable ## fit the model model &lt;- glmnet(x = x, y = y, family = &quot;gaussian&quot;, alpha = alpha, nlambda = nlambda) ## forecast pred &lt;- predict(model, newx = x[nrow(x),]) ## Output pred*d_sd[target] + d_mean[target] } # penalized_reg(d, &quot;INDPRO&quot;, 1, 1) # one value for each lambda ## Random forest library(randomForest) forest &lt;- function(d, target, horizon, seed = 1, ntree = 100) { ## Scale the data d_scaled &lt;- scale(d) d_mean &lt;- attr(d_scaled, &quot;scaled:center&quot;) d_sd &lt;- attr(d_scaled, &quot;scaled:scale&quot;) ## get the target and predictors t_max &lt;- nrow(d) y &lt;- d_scaled[(horizon+1):t_max, target] x &lt;- d_scaled[1:(t_max-horizon), ] # include also lagged target variable ## fit the model set.seed(seed) model &lt;- randomForest(x = x, y = y, ntree = ntree) ## forecast pred &lt;- predict(model, newdata = x[nrow(x),]) ## Output pred*d_sd[target] + d_mean[target] } # forest(d, &quot;INDPRO&quot;, 1) 3.3 Forecast evaluation We can now run the algorithms and compare their forecasting performances over the 2002-2020 period. ## Initialize objects forecast_list &lt;- list( pcr = c(), ridge = list(), lasso = list(), forest = c() ) # choose target variable and forecast horizon target &lt;- &quot;UNRATE&quot; horizon &lt;- 1 # pick the initial window for training and choose the test period initial_window &lt;- sum(dates &lt; &quot;2002-01-01&quot;) idx_eval &lt;- which(((dates &lt; &quot;2020-02-01&quot;)) &amp; dates &gt;= &quot;2002-01-01&quot;) - initial_window # total steps of the forecast evaluation and selection of the test data n_steps &lt;- nrow(d) - initial_window - horizon + 1 data_test &lt;- d[(initial_window+horizon):nrow(d), target] ## expanding window forecast evaluation for (s in 1:n_steps) { cat(&quot;\\rStep&quot;, s, &quot;of&quot;, n_steps) data_train &lt;- d[1:(initial_window+s-1),] forecast_list$pcr[s] &lt;- pcr(data_train, target, n_components = 4, horizon = horizon) forecast_list$ridge[[s]] &lt;- penalized_reg(data_train, target, horizon = horizon, alpha = 0) forecast_list$lasso[[s]] &lt;- penalized_reg(data_train, target, horizon = horizon, alpha = 1) forecast_list$forest[s] &lt;- forest(data_train, target, horizon = horizon, ntree = 100) } Remark: here we just pick one value of \\(\\lambda\\) among the many that we used for estimating ridge and LASSO regressions. A more rigourous approach would consist in using either information criteria or cross validation to pick the optimal \\(\\lambda\\). We omit this part for simplicity of exposition. ## Comppute the RMSE of the predictions rmse &lt;- function(y, f) {sqrt(mean((y-f)^2))} pred_ridge &lt;- sapply(forecast_list$ridge, function(x) x[30]) pred_lasso &lt;- sapply(forecast_list$lasso, function(x) x[8]) pred_mean &lt;- rep(mean(d[1:initial_window, target]), n_steps) rbind( mean = rmse(data_test[idx_eval], pred_mean[idx_eval]), pcr = rmse(data_test[idx_eval], forecast_list$pcr[idx_eval]), forest = rmse(data_test[idx_eval], forecast_list$forest[idx_eval]), ridge = rmse(data_test[idx_eval], pred_ridge[idx_eval]), lasso = rmse(data_test[idx_eval], pred_lasso[idx_eval]) ) ## [,1] ## mean 0.1600012 ## pcr 0.1513172 ## forest 0.1676554 ## ridge 0.1475805 ## lasso 0.1416051 ## Plot the forecasted values ground_truth &lt;- ts(data_test[idx_eval], start = c(2002, 1), freq = 12) pred_benchmark &lt;- ts(pred_mean[idx_eval], start = c(2002, 1), freq = 12) pred_pcr &lt;- ts(forecast_list$pcr[idx_eval], start = c(2002, 1), freq = 12) pred_lasso &lt;- ts(pred_lasso[idx_eval], start = c(2002, 1), freq = 12) plot.ts(ground_truth, type = &quot;l&quot;, lwd = 2, main = &quot;Forecasts VS. ground truth&quot;, ylab = &quot;UNRATE change&quot;) lines(pred_benchmark, type = &quot;l&quot;, col = &quot;darkgrey&quot;) lines(pred_pcr, type = &quot;b&quot;, col = &quot;darkred&quot;, pch = 18) lines(pred_lasso, type = &quot;b&quot;, col = &quot;steelblue&quot;, pch = 19) legend(&quot;topright&quot;, c(&quot;PCR&quot;, &quot;LASSO&quot;), col = c(&quot;darkred&quot;, &quot;steelblue&quot;), pch = c(18, 19)) ## Diebold-Mariano test library(forecast) err_benchmark &lt;- data_test[idx_eval] - pred_mean[idx_eval] err_lasso &lt;- data_test[idx_eval] - pred_lasso[idx_eval] err_pcr &lt;- data_test[idx_eval] - forecast_list$pcr[idx_eval] # LASSO dm.test(err_benchmark, err_lasso, alternative = &quot;greater&quot;) ## ## Diebold-Mariano Test ## ## data: err_benchmarkerr_lasso ## DM = 3.9017, Forecast horizon = 1, Loss function power = 2, p-value = ## 6.381e-05 ## alternative hypothesis: greater # PCR dm.test(err_benchmark, err_pcr, alternative = &quot;greater&quot;) ## ## Diebold-Mariano Test ## ## data: err_benchmarkerr_pcr ## DM = 1.0484, Forecast horizon = 1, Loss function power = 2, p-value = ## 0.1478 ## alternative hypothesis: greater ## plot the cumulated squared errors over time # compute the (normalized) cumulated squared errors and convert to ts object err2_benchmark &lt;- ts(cumsum((err_benchmark)^2), start = c(2002, 1), frequency = 12) err2_pcr &lt;- ts(cumsum((err_pcr)^2), start = c(2002, 1), frequency = 12) err2_lasso &lt;- ts(cumsum((err_lasso)^2), start = c(2002, 1), frequency = 12) err2_constant &lt;- sum(err_benchmark^2) # plot plot.ts(err2_benchmark/err2_constant, lwd = 2, ylab = &quot;Cumulated squared errors&quot;, main = &quot;Forecast errors over time&quot;, xlab = &quot;&quot;) lines(err2_pcr/err2_constant, col = &quot;steelblue&quot;, lwd = 2) lines(err2_lasso/err2_constant, col = &quot;darkred&quot;, lwd = 2) rect(2008,-1,2009.5,1.5,col = rgb(0.6,0.1,0.1,1/4)) legend(&quot;topleft&quot;, c(&quot;Sample mean&quot;, &quot;PCR&quot;, &quot;LASSO&quot;), col=c(&quot;black&quot;, &quot;steelblue&quot;, &quot;darkred&quot;), lwd=6) "],["session04.html", "Session 4 ARMA(1,1) model 4.1 MLE for the ARMA(1,1) 4.2 Exercises", " Session 4 ARMA(1,1) model 4.1 MLE for the ARMA(1,1) In this session we consider the ARMA(1,1) model: \\[ y_t = c + \\phi y_{t-1} + \\theta \\varepsilon_{t-1} + \\varepsilon_t, \\quad \\varepsilon_t \\sim WN(0, \\sigma^2_\\varepsilon) \\] Below we simulate an ARMA(1,1) model with Gaussian iid noise terms: \\(\\varepsilon_t \\sim \\mathcal{N}(0, \\sigma^2_\\varepsilon)\\). ## Setup parameters for simulation t_max &lt;- 800 y0 &lt;- 0 const &lt;- 0 phi &lt;- 0.9 theta &lt;- -0.5 sigma_eps &lt;- 1 ## Simulation ARMA(1,1) eps &lt;- rnorm(t_max+1, sd = sigma_eps) y &lt;- c() y[1] &lt;- y0 for (t in 2:t_max) { y[t] &lt;- const + phi*y[t-1] + theta*eps[t-1] + eps[t] } plot.ts(y) ## Autocorrelograms acf(y, lwd = 3) pacf(y, lwd = 3) We now turn to estimate the model by maximum likelihood. We can then compare the estimates with the true values of the parameters that we used to simulate the data. Notice that the distribution of observation \\(y_t\\) given all the information set \\(I_{t-1}\\) available up to time \\(t-1\\) is \\[ y_t | I_{t-1} \\sim \\mathcal{N}(c + \\phi y_{t-1} + \\theta \\varepsilon_{t-1}, \\ \\sigma^2_\\varepsilon). \\] Let $ = (c, , , ^2_)$ denote the vector of parameters of the model. The conditional likelihood can be obtained as: \\[ L(\\eta; y_1, \\dots, y_T) = \\prod_{t=2}^T \\frac{1}{\\sqrt{2\\pi\\sigma^2_{\\varepsilon}}} \\exp\\left( -\\frac{1}{2\\sigma^2_\\varepsilon} (y_t - c - \\phi y_{t-1} - \\theta \\varepsilon_{t-1} )^2 \\right) \\] where the conditioning is on the first observation \\(y_1\\). Taking the logarithm and defining \\(\\hat \\varepsilon_t = y_t - c - \\phi y_{t-1} - \\theta \\varepsilon_{t-1}\\) we get \\[ \\ell(\\eta ; y_1, \\dots, y_T) = - \\frac{T-1}{2} \\log(2\\pi\\sigma^2_\\varepsilon) - \\frac{1}{2\\sigma^2_\\varepsilon} \\sum_{t=2}^T \\hat\\varepsilon_t^2 \\] The estimate of the innovations can be obtained using a filtering procedure: for a given value of the parameters \\(\\eta = (c, \\phi, \\theta, \\sigma^2_\\varepsilon)\\), we set \\(\\hat\\varepsilon_1\\) equal to the deviation from the unconditional mean of the first observation, \\(\\hat\\varepsilon_1 = y_1 - \\frac{c}{1-\\phi}\\), and then we compute \\(\\hat\\varepsilon_{t} = y_t - c - \\phi y_{t-1} + \\theta \\hat\\varepsilon_{t-1}\\) recursively for \\(t = 2, \\dots, T\\). Then we can use the estimated sequence of innovations \\(\\{\\hat\\varepsilon_t\\}_{t=2}^T\\) to evaluate the log-likelihood in \\(\\eta\\). ## Estimation: filtering ## 1-step ahead conditional mean of ARMA(1,1) model arma_filter &lt;- function(x, params){ # get parameters const &lt;- params[1] phi &lt;- params[2] theta &lt;- params[3] ## initialize intercept, innovation mu &lt;- rep(0, length(x)) mu[1] &lt;- const/(1-phi) eps &lt;- rep(0, length(x)) eps[1] &lt;- x[1] - mu[1] # filter and innovations for(t in 2:length(x)){ mu[t] &lt;- const + phi*x[t-1] + theta*eps[t-1] eps[t] &lt;- x[t] - mu[t] } # output: estimated innovations eps } arma_loglik &lt;- function(x, params){ # params now include (c, phi, theta, sigma2) t_max &lt;- length(x) sigma2 &lt;- params[4] eps &lt;- arma_filter(x, params[1:3]) # compute loglik loglik &lt;- -0.5*t_max*log(2*pi*sigma2) - (1/(2*sigma2))*sum(eps^2) # nlm() minimizes functions --&gt; we swap the sign of the log-likelihood # (max L = min -L) -loglik } ## estimation param_estim &lt;- nlm(arma_loglik, p = c(0, 0.1, 0, 1), x = y)$estimate ## Warning in nlm(arma_loglik, p = c(0, 0.1, 0, 1), x = y): NA/Inf sostituito da ## valore massimo positivo ## Warning in nlm(arma_loglik, p = c(0, 0.1, 0, 1), x = y): NA/Inf sostituito da ## valore massimo positivo ## Warning in nlm(arma_loglik, p = c(0, 0.1, 0, 1), x = y): NA/Inf sostituito da ## valore massimo positivo cbind(c(const, phi, theta, sigma_eps), round(param_estim, 3)) ## [,1] [,2] ## [1,] 0.0 -0.005 ## [2,] 0.9 0.873 ## [3,] -0.5 -0.515 ## [4,] 1.0 1.030 4.2 Exercises Exercise 1 (LASSO as OLS with thresholding) Consider the linear regression model \\(y = X\\beta + \\varepsilon\\) with uncorrelated regressors: \\(X&#39;X = I_n\\), where \\(X\\in\\mathbb{R}^{T\\times n}\\). Show that the LASSO estimator \\[ \\hat\\beta^{(\\lambda)} = \\arg\\min_{\\beta \\in \\mathbb{R}^n} \\ (y-X\\beta)&#39;(y-X\\beta) + \\lambda ||\\beta||_1 \\] can be written as \\[ \\hat\\beta_j^{(\\lambda)} = \\begin{cases} \\hat\\beta_j^{OLS} - \\frac{\\lambda}{2} &amp; \\qquad \\text{if} \\quad \\hat\\beta_j^{OLS} &gt; \\frac{\\lambda}{2} \\\\ \\hat\\beta_j^{OLS} + \\frac{\\lambda}{2} &amp; \\qquad \\text{if} \\quad \\hat\\beta_j^{OLS} &lt; -\\frac{\\lambda}{2} \\\\ 0 &amp; \\qquad \\text{if} \\quad \\hat\\beta_j^{OLS} \\in \\left[ -\\frac{\\lambda}{2}, \\frac{\\lambda}{2} \\right]\\\\ \\end{cases} \\] where \\(\\hat\\beta_j^{OLS}\\) denotes the \\(j\\)-th entry of the OLS estimator and \\(j = 1, \\dots, n\\). Exercise 2 (MA(\\(\\infty\\)) representation of stationary ARMA(1,1)) Show that the ARMA(1,1) process with \\(|\\phi| &lt; 1\\) \\[ y_t = c + \\phi y_{t-1} + \\theta \\varepsilon_{t-1} + \\varepsilon_t, \\quad \\varepsilon_t \\sim WN(0, \\sigma^2_\\varepsilon) \\] can be rewritten as \\[ y_t = \\mu + \\sum_{j=0}^\\infty \\psi_j \\varepsilon_{t-j}, \\] for \\(\\mu = \\frac{c}{1-\\phi}\\), \\(\\psi_0 = 1\\), \\(\\psi_j = (\\phi + \\theta)\\phi^{j-1}\\). Exercise 3 (autocovariance function of the ARMA(1,1)) Show that the covariance function \\(\\gamma(k) = \\text{cov}(y_t, y_{t-k})\\) of the ARMA(1,1) process \\[ y_t = c + \\phi y_{t-1} + \\theta \\varepsilon_{t-1} + \\varepsilon_t, \\quad \\varepsilon_t \\sim WN(0, \\sigma^2_\\varepsilon) \\] with \\(|\\phi &lt; 1|\\) can be written as \\[ \\gamma(k) = \\begin{cases} \\sigma^2_\\varepsilon \\left(1 + \\frac{(\\phi+\\theta)^2}{1-\\phi^2}\\right) &amp; \\qquad \\text{for} \\quad k=0 \\\\[1em] \\sigma^2_\\varepsilon \\left(\\phi+\\theta + \\frac{(\\phi+\\theta)^2\\phi}{1-\\phi^2}\\right) &amp; \\qquad \\text{for} \\quad k=1 \\\\[1em] \\phi^{k-1} \\ \\gamma(1) &amp; \\qquad \\text{for} \\quad k&gt;1 \\end{cases} \\] Hint: you may use the fact that for a linear time series \\(y_t = \\mu + \\sum_{j=0}^\\infty \\psi_j \\varepsilon_{t-j}\\) the autocovariance function is given by \\[ \\gamma(k) = \\sigma^2_\\varepsilon \\sum_{j=k}^\\infty \\psi_j \\psi_{j-k}, \\] provided that \\(\\sum_{j=0}^{\\infty} \\psi_j^2 &lt; \\infty\\). "],["session05.html", "Session 5 ARMA models in practice 5.1 Forecasting the U.S. GDP growth 5.2 Exercises", " Session 5 ARMA models in practice ## load libraries library(moments) ## function to plot time series myplot &lt;- function( dates , y , col=&#39;darkblue&#39; , t=&#39;l&#39; , lwd=2 , ylim=NULL , main=NULL ){ if( is.null(main) ){ par( mar=c(2,2,0.1,0.1) ) } plot( dates , y , t=t , col=col , lwd=lwd , axes=F , xlab=&#39;&#39; , ylab=&#39;&#39; , xaxs=&quot;i&quot; , ylim=ylim , main=main ) xticks &lt;- axis.Date(1, x=dates, at=seq(dates[1], dates[length(dates)], &quot;year&quot;) , lwd=0, lwd.tick=1, tck=0.02) yticks &lt;- axis(2 , lwd=0, lwd.tick=1, tck=0.02) axis.Date(3, x=dates, at=seq(dates[1], dates[length(dates)], &quot;year&quot;), lwd=0, lwd.tick=1, tck=0.02, lab=F) axis(4, lwd=0, lwd.tick=1, tck=0.02, lab=F) abline( h=yticks , lty=3 ) abline( v=xticks , lty=3 ) box() } 5.1 Forecasting the U.S. GDP growth In this session we consider an application of ARMA models to forecasting the U.S. GDP growth rates. ## Load U.S. GDP growth rate D &lt;- read.table(&#39;../data/gdp-us-grate.csv&#39;) dates &lt;- as.Date(as.character(D[,1]),&#39;%Y-%m-%d&#39;) ## Setup H &lt;- 6 # predict 1,2,...,H steps ahead N &lt;- nrow(D)-6 y &lt;- D[1:N,2] y.out &lt;-D[(N+1):(N+H),2] # LBQ Test for autocorrelation Box.test( y, lag=22 , type=&quot;Ljung-Box&quot;) ## ## Box-Ljung test ## ## data: y ## X-squared = 82.561, df = 22, p-value = 6.112e-09 # ACF &amp; PACF par( mar=c(2,2,1,1) , mfrow=c(2,1) ) acf( y , ylim=c(-0.2,1) , lwd=5 , xlim=c(0,25) , col=&#39;darkorange2&#39; , tck=0.02) legend(&#39;topright&#39;,c(&#39;ACF&#39;),col=c(&#39;darkorange2&#39;),lwd=3) pacf( y , ylim=c(-0.2,1) , lwd=5 , xlim=c(0,25) , col=&#39;darkorange2&#39; , tck=0.02) legend(&#39;topright&#39;,c(&#39;PACF&#39;),col=c(&#39;darkorange2&#39;),lwd=3) Estimation ar1 &lt;- arima(y,order=c(1,0,0)) ma1 &lt;- arima(y,order=c(0,0,1)) ma2 &lt;- arima(y,order=c(0,0,2)) arma11 &lt;- arima(y,order=c(1,0,1)) # Information criteria ar1_aic &lt;- (-2*ar1$loglik+2*3)/N # (constant, phi, sigma_e) ma1_aic &lt;- (-2*ma1$loglik+2*3)/N # (constant, theta, sigma_e) ma2_aic &lt;- (-2*ma2$loglik+2*4)/N # (constant, theta1, theta2, sigma_e) arma11_aic &lt;- (-2*arma11$loglik+2*4)/N # (constant, phi, theta, sigma_e) ar1_bic &lt;- (-2*ar1$loglik+log(N)*3)/N ma1_bic &lt;- (-2*ma1$loglik+log(N)*3)/N ma2_bic &lt;- (-2*ma2$loglik+log(N)*4)/N arma11_bic &lt;- (-2*arma11$loglik+log(N)*4)/N ## table of likelihood and ICs tab1 &lt;- round( rbind( c(ar1$loglik,ma1$loglik.ma2$loglik,arma11$loglik), c(ar1_aic,ma1_aic,ma2_aic,arma11_aic) , c(ar1_bic,ma1_bic,ma2_bic,arma11_bic) ) , 3 ) row.names(tab1) &lt;- c(&quot;loglik&quot;, &quot;AIC&quot;, &quot;BIC&quot;) colnames(tab1) &lt;- c(&quot;AR(1)&quot;, &quot;MA(1)&quot;, &quot;MA(2)&quot;, &quot;ARMA(1,1)&quot;) tab1 ## AR(1) MA(1) MA(2) ARMA(1,1) ## loglik -747.736 -746.702 -747.736 -746.702 ## AIC 5.382 5.419 5.371 5.381 ## BIC 5.421 5.458 5.423 5.433 Forecasting ## get forecasts ar1_pred &lt;- predict(ar1, n.ahead=H) ma1_pred &lt;- predict(ma1, n.ahead=H) ma2_pred &lt;- predict(ma2, n.ahead=H) arma11_pred &lt;- predict(arma11, n.ahead=H) ## get fitted values ar1_mu &lt;- y-ar1$residuals ma1_mu &lt;- y-ma1$residuals ma2_mu &lt;- y-ma2$residuals arma11_mu &lt;- y-arma11$residuals ## compute RMSE rmse &lt;- function(y, f) {sqrt(mean((y-as.numeric(f))^2))} ar1_mse &lt;-rmse(y.out, ar1_pred$pred) ma1_mse &lt;-rmse(y.out, ma1_pred$pred) ma2_mse &lt;-rmse(y.out, ma2_pred$pred) arma11_mse &lt;-rmse(y.out, arma11_pred$pred) ## Plot par(mfrow = c(1,2)) myplot( dates[(N-10):(N+H)] , c(y[(N-10):N], y.out) , t=&#39;b&#39;, main=sprintf(&#39;AR(1) RMSE %3.3f&#39;,ar1_mse) , ylim=c(0,7) , col=&#39;darkorange&#39; ) abline( v=dates[N] , lwd=2 ) abline( h=ar1$coef[&#39;intercept&#39;] , lwd=2 ) lines( dates[(N-10):N] , ar1_mu[(N-10):N] , t=&#39;l&#39; , lwd=2 , col=&#39;blue3&#39; ) lines( dates[(N+1):(N+H)] , as.numeric(ar1_pred$pred) , t=&#39;b&#39; , lwd=2 , col=&#39;blue3&#39; ) myplot( dates[(N-10):(N+H)] , c(y[(N-10):N], y.out) , t=&#39;b&#39; , main=sprintf(&#39;ARMA(1,1) RMSE %3.3f&#39;,arma11_mse) , ylim=c(0,7) , col=&#39;darkorange&#39; ) abline( v=dates[N] , lwd=2 ) abline( h=arma11$coef[&#39;intercept&#39;] , lwd=2 ) lines( dates[(N-10):N] , arma11_mu[(N-10):N] , t=&#39;l&#39; , lwd=2 , col=&#39;blue3&#39; ) lines( dates[(N+1):(N+H)] , as.numeric(arma11_pred$pred) , t=&#39;b&#39; , lwd=2 , col=&#39;blue3&#39; ) par(mfrow = c(1,2)) myplot( dates[(N-10):(N+H)] , c(y[(N-10):N], y.out) , t=&#39;b&#39;, main=sprintf(&#39;MA(2) RMSE %3.3f&#39;,ma2_mse) , ylim=c(0,7) , col=&#39;darkorange&#39; ) abline( v=dates[N] , lwd=2 ) abline( h=ma2$coef[&#39;intercept&#39;] , lwd=2 ) lines( dates[(N-10):N] , ma2_mu[(N-10):N] , t=&#39;l&#39; , lwd=2 , col=&#39;blue3&#39; ) lines( dates[(N+1):(N+H)] , as.numeric(ma2_pred$pred) , t=&#39;b&#39; , lwd=2 , col=&#39;blue3&#39; ) myplot( dates[(N-10):(N+H)] , c(y[(N-10):N], y.out) , t=&#39;b&#39; , main=sprintf(&#39;MA(1) RMSE %3.3f&#39;,ma1_mse) , ylim=c(0,7) , col=&#39;darkorange&#39; ) abline( v=dates[N] , lwd=2 ) abline( h=ma1$coef[&#39;intercept&#39;] , lwd=2 ) lines( dates[(N-10):N] , ma1_mu[(N-10):N] , t=&#39;l&#39; , lwd=2 , col=&#39;blue3&#39; ) lines( dates[(N+1):(N+H)] , as.numeric(ma1_pred$pred) , t=&#39;b&#39; , lwd=2 , col=&#39;blue3&#39; ) 5.2 Exercises Exercise 1 (Best forecast under the square loss) Show that the best forecast under the square loss \\[ L(y_{t+h}, \\ \\hat{y}_{t+h|t}) = (y_{t+h}-\\hat{y}_{t+h|t})^2 \\] for some forecast horizon \\(h \\in \\mathbb{N}\\) is \\[ \\hat{y}_{t+h|t} = \\mathbb{E} [y_{t+h} \\ | \\ y_t, \\dots, y_1] \\] Exercise 2 (Best forecast under the absolute loss) Show that the best forecast under the absolute loss \\[ L(y_{t+h}, \\ \\hat{y}_{t+h|t}) = |y_{t+h}-\\hat{y}_{t+h|t}| \\] for some forecast horizon \\(h \\in \\mathbb{N}\\) is \\[ \\hat{y}_{t+h|t} = \\text{median}(y_{t+h} \\ | \\ y_t, \\dots, y_1) \\] Exercise 3 (Invertibility of MA(1)) Consider the MA(1) process \\[ y_t = \\theta \\varepsilon_{t-1} + \\varepsilon_t. \\] Show that: if \\(|\\theta|&lt;1\\), then the process is invertible in the past observed values: \\[ \\varepsilon_t = \\sum_{j=0}^{\\infty} (-\\theta)^j y_{t-j} \\] if \\(|\\theta|&gt;1\\), then the process is invertible in the future observed values: \\[ \\varepsilon_t = \\frac{1}{\\theta} \\sum_{j=0}^{\\infty} \\left(-\\frac{1}{\\theta}\\right)^j y_{t+j+1} \\] "],["session06.html", "Session 6 Volatility modeling 6.1 GARCH(1,1) estimation 6.2 Exercises", " Session 6 Volatility modeling 6.1 GARCH(1,1) estimation In this session, we implement the maximum likelihood estimation of the GARCH(1,1) model. We consider a Gaussian GARCH(1,1) \\[ \\begin{aligned} r_t &amp;= \\sigma^2_t z_t \\\\[1ex] \\sigma^2_t &amp;= \\omega + \\alpha r_{t-1}^2 + \\beta \\sigma^2_{t-1} \\end{aligned} \\] where \\(z_t \\sim \\mathcal{N}(0, 1)\\). The log-likelihood is (Exercise 3): \\[ \\ell(\\theta; r_1, \\dots, r_T) = -\\frac{T-1}{2}\\log(2\\pi) - \\frac{1}{2}\\sum_{t=2}^T\\log\\hat\\sigma_t -\\frac{1}{2} \\sum_{t=2}^T \\frac{r_t^2}{\\hat\\sigma^2_t} \\] The values of the latent volatility \\(\\{\\sigma_2^2, \\sigma_3^2, \\dots, \\sigma_T^2\\}\\) can be estimated using the following filtering procedure for each given value \\(\\theta = (\\omega, \\alpha, \\beta)\\): set \\(\\hat\\sigma^2_t = \\hat{\\text{Var}}(r_t)\\) for \\(t = 2, \\dots, T\\) set \\(\\hat\\sigma^2_t = \\omega + \\alpha r_{t-1}^2 + \\beta \\hat\\sigma^2_{t-1}\\) We simulate the data according to the GARCH(1,1) process and compare the MLE with the true parameters. ## Simulate data t_max &lt;- 1000 w &lt;- 0.01 alpha &lt;- 0.05 beta &lt;- 0.949 z &lt;- rnorm(t_max) sigma &lt;- c(1, rep(NA, t_max)) r &lt;- c(sigma[1]*z[1], rep(NA, t_max)) for (t in 2:(t_max+1)) { set.seed(t*212) # for reproducibility sigma[t] &lt;- w + alpha*r[t-1] + beta*sigma[t-1] r[t] &lt;- sigma[t]*z[t] } r &lt;- r[100:1000] plot.ts(r) plot.ts(r^2) Estimation ## filter garch11_filter &lt;- function(data, params){ # initializations omega &lt;- params[1] alpha &lt;- params[2] beta &lt;- params[3] T &lt;- length(data) sig2 &lt;- numeric(T) z &lt;- numeric(T) loglik &lt;- 0 sig2[1] &lt;- var(data); z[1] &lt;- data[1]/sqrt(sig2[1]) # for loop calculating one-step-ahead for (t in 2:T){ sig &lt;- omega + alpha * data[t-1]^2 + beta * sig2[t-1] sig2[t] &lt;- sig; z[t] &lt;- data[t]/sqrt(sig) } # loglik loglik &lt;- -T/2*log(2*pi) - sum(log(sig2))/2 - sum(data^2/sig2)/2 return(list(sig2 = sig2, z = z, loglik = loglik)) } ## likelihood garch11_objective &lt;- function(data, params) { #initializations omega &lt;- params[1] alpha &lt;- params[2] beta &lt;- params[3] T &lt;- length(data) sig2 &lt;- garch11_filter(data, params)$sig2 # if-else statement calculating negative loglik if (all(is.finite(params)) &amp; omega &gt; 0 &amp; alpha &gt; 0 &amp; beta &gt; 0 &amp; alpha + beta &lt; 1) { neg_loglik &lt;- -(-T/2*log(2*pi) - sum(log(sig2))/2 - sum(data^2/sig2)/2) } else { neg_loglik &lt;- Inf } return(neg_loglik) } ## MLE garch11_mle &lt;- function(data, params) { # nlminb function optimizing parameters fit &lt;- nlminb(start = params, objective = garch11_objective, data = data, lower = 0.0001, upper = 1) return(param_mle = fit$par) } mle &lt;- garch11_mle(r, c(0, 0.1, 0.1)) For comparison, we also estimate the model using the garch function in the package tseries. ## estimate garch(1,1) using built-in function library(tseries) garch_tseries &lt;- garch(r, c(1,1), verbose = FALSE) cbind(mle, coef(garch_tseries), c(w, alpha, beta)) |&gt; round(3) ## mle ## a0 0.001 0.001 0.010 ## a1 0.037 0.037 0.050 ## b1 0.931 0.931 0.949 6.2 Exercises Exercise 1 (ARCH(\\(\\infty\\)) representation of GARCH(1,1)) Show that the GARCH(1,1) \\[ \\begin{aligned} r_t &amp;= \\sigma^2_t z_t \\\\[1ex] \\sigma^2_t &amp;= \\omega + \\alpha r_{t-1}^2 + \\beta \\sigma^2_{t-1} \\end{aligned} \\] with \\(\\mathbb{E}[z_t] = 0\\), \\(\\mathbb{E}[z^2_t] = 1\\) can be rewritten as an ARCH(\\(\\infty\\)) with \\[ \\sigma^2_t = \\frac{\\omega}{1-\\beta} + \\alpha \\sum_{j=0}^\\infty \\beta^j \\ r^2_{t-j-1} \\] under the assumption that \\(|\\beta| &lt; 1\\). Exercise 2 (Autocovariance of the GARCH(1,1)) Consider the GARCH(1,1) \\[ \\begin{aligned} r_t &amp;= \\sigma^2_t z_t \\\\[1ex] \\sigma^2_t &amp;= \\omega + \\alpha r_{t-1}^2 + \\beta \\sigma^2_{t-1} \\end{aligned} \\] with \\(\\mathbb{E}[z_t] = 0\\), \\(\\mathbb{E}[z^2_t] = 1\\). Show that: \\[ \\gamma(k) = \\text{cov}(r_t, r_{t-k}) = \\begin{cases} \\frac{\\omega}{1-\\alpha-\\beta} \\qquad &amp; k = 0 \\\\ 0 &amp; k \\neq 0 \\end{cases} \\] [Difficult question] Also show that \\[ \\gamma_2(k) = \\text{cov}(r^2_t, r^2_{t-k}) = \\begin{cases} \\text{Var}(r^2_t - \\sigma^2_t)\\left[1+\\frac{\\alpha+2\\beta}{1-(\\alpha+\\beta)^2}\\right] \\qquad &amp; k = 0 \\\\[1em] \\text{Var}(r^2_t - \\sigma^2_t)\\left[\\alpha+2\\beta+\\frac{(\\alpha+2\\beta)^2 (\\alpha+\\beta)}{1-(\\alpha+\\beta)^2}\\right] \\qquad &amp; k = 1 \\\\[1em] (\\alpha+\\beta)^{k-1}\\gamma(1) &amp; k \\geq 2 \\end{cases} \\] where \\(\\text{Var}(r^2_t - \\sigma^2_t) = (\\mu_4 - 1)\\left( \\sigma_4 - \\left(\\frac{\\omega}{1-\\alpha-\\beta}\\right)^2 \\right)\\), \\(\\sigma^4 = \\mathbb{E}[\\sigma^4_t]\\) (you do not need to find the explicit expression for this in terms of the parameters) and \\(\\mu_4 = \\mathbb{E}[z_t^4]\\). Hint: Show that the GARCH(1,1) admits an ARMA(1,1) representation \\(\\sigma_t^2 = \\omega + (\\alpha+\\beta)r^2_{t-1} + \\beta(r^2_{t-1}-\\sigma^2_{t-1}) + (r^2_{t}-\\sigma^2_{t})\\) and apply the formula for the autocovariance of the ARMA(1,1) (see Exercise 3 in Session 4). Exercise 3 (Log-likelihood of the GARCH(1,1)) Consider a Gaussian GARCH(1,1) \\[ \\begin{aligned} r_t &amp;= \\sigma^2_t z_t \\\\[1ex] \\sigma^2_t &amp;= \\omega + \\alpha r_{t-1}^2 + \\beta \\sigma^2_{t-1} \\end{aligned} \\] where \\(z_t \\sim \\mathcal{N}(0, 1)\\). Show that the conditional log-likelihood of the model is \\[ \\ell(\\theta; r_1, \\dots, r_T) = -\\frac{T-1}{2}\\log(2\\pi) - \\frac{1}{2}\\sum_{t=2}^T\\log\\hat\\sigma_t -\\frac{1}{2} \\sum_{t=2}^T \\frac{r_t^2}{\\hat\\sigma^2_t} \\] where \\(\\hat\\sigma_t^2\\) is the predicted value of the latent volatility computed using the filtering procedure described in the session. "],["session07.html", "Session 7 Volatility modeling in practice 7.1 The ARMA(1,1)-TGARCH(1,1) model 7.2 Modeling the S&amp;P 500 volatility 7.3 Exercises", " Session 7 Volatility modeling in practice 7.1 The ARMA(1,1)-TGARCH(1,1) model In this session we include the conditionally-heteroskedastic models into the ARMA framework. In particular, we consider an ARMA(1,1) model with conditionally-heteroskedastic innovations and asymmetric effects. For simplicity, we just consider first-order difference equations, but the model can be generalized to include more lags. The model is an ARMA(1,1)-TGARCH(1,1) of the following form: \\[ \\begin{aligned} y_t &amp;= c + \\phi y_{t-1} + \\theta \\varepsilon_{t-1} + \\varepsilon_t \\\\ \\varepsilon_t &amp;= \\sigma_t z_t \\\\ \\sigma^2_t &amp;= \\omega + \\alpha y_{t-1}^2 + \\beta \\sigma^2_{t-1} + \\gamma y_{t-1}^2 \\mathbb{1}_{y_{t-1}&lt;0} \\end{aligned} \\] Throughout this session, we consider \\(z_t \\sim \\mathcal{N}(0,1)\\) and we estimate the model via maximum-likelihood. Let \\(I_t = \\{y_1, \\dots, y_t, \\varepsilon_1, \\dots, \\varepsilon_t, \\sigma_1, \\dots, \\sigma_t\\}\\). The log-likelihood of the model is: \\[ \\ell(\\theta; I_T) = -\\frac{T-1}{2} \\log(2\\pi) - \\frac{1}{2}\\sum_{t=2}^T \\log \\sigma_t(I_{t-1}; \\theta) - \\frac{1}{2}\\sum_{t=2}^T \\frac{( \\varepsilon_t(I_{t-1}; \\theta))^2}{\\sigma^2_t(I_{t-1}; \\theta)}, \\] where expressions for \\(\\sigma_t(I_{t-1}; \\theta), \\ \\varepsilon_t(I_{t-1}; \\theta)\\) can be found using a standard filtering procedure (Exercise 3). ## Simulate data from ARMA(1,1)-TGARCH(1,1) process # set parameters t_max &lt;- 1000 c &lt;- 0 phi &lt;- 0.85 theta &lt;- -0.1 omega &lt;- 0.01 alpha &lt;- 0.1 beta &lt;- 0.85 gamma &lt;- 0.05 # simulate set.seed(123) z &lt;- rnorm(t_max) epsilon &lt;- c(0, rep(NA, t_max)) sigma2 &lt;- c(1, rep(NA, t_max)) y &lt;- c(sigma2[1]*z[1], rep(NA, t_max)) for (t in 2:(t_max+1)) { set.seed(t*212) # for reproducibility # sigma2[t] &lt;- omega + alpha*y[t-1]^2 + beta*sigma2[t-1] + gamma*y[t-1]^2 + gamma*y[t-1]^2*(y[t-1]&lt;0) sigma2[t] &lt;- omega + alpha*y[t-1]^2 + beta*sigma2[t-1] + gamma*y[t-1]^2*(y[t-1]&lt;0) epsilon[t] &lt;- sigma2[t]*z[t] y[t] &lt;- c + phi*y[t-1] + theta*epsilon[t-1] + epsilon[t] } y &lt;- y[50:t_max] # plot simulated series plot.ts(y) # plot simulated series squared plot.ts(y^2) ## filter arma11tgarch11_filter &lt;- function(y, params){ # initializations c &lt;- params[1] phi &lt;- params[2] theta &lt;- params[3] omega &lt;- params[4] alpha &lt;- params[5] beta &lt;- params[6] gamma &lt;- params[7] t_max &lt;- length(y) eps &lt;- c(0, rep(NA, t_max-1)) sig2 &lt;- c(1, rep(NA, t_max-1)) z &lt;- rep(NA, t_max) loglik &lt;- 0 sig2[1] &lt;- var(y) z[1] &lt;- y[1]/sqrt(sig2[1]) # for loop calculating one-step-ahead for (t in 2:t_max){ eps[t] &lt;- y[t] - c - phi*y[t-1] - theta*eps[t-1] sig2[t] &lt;- omega + alpha*y[t-1]^2 + beta*sig2[t-1] + gamma*y[t-1]^2*(y[t-1]&lt;0) z[t] &lt;- eps[t]/sqrt(sig2[t]) } # loglik loglik &lt;- - sum(log(sig2[2:t_max])) - sum(eps[2:t_max]^2/sig2[2:t_max]) # *0.5 + constant terms # output return(list(sig2 = sig2, eps = eps, z = z, loglik = loglik)) } ## likelihood arma11tgarch11_objective &lt;- function(y, params) { #initializations c &lt;- params[1] phi &lt;- params[2] theta &lt;- params[3] omega &lt;- params[4] alpha &lt;- params[5] beta &lt;- params[6] gamma &lt;- params[7] t_max &lt;- length(y) res_filter &lt;- arma11tgarch11_filter(y, params) sig2 &lt;- res_filter$sig2 eps &lt;- res_filter$eps # if-else statement calculating negative loglik # if (all(is.finite(params)) &amp; omega&gt;=0 &amp; alpha&gt;0 &amp; beta&gt;0 &amp; gamma&gt;0 &amp; (alpha+beta+gamma/2)&lt;1) { if (all(is.finite(params)) &amp; (alpha+beta+gamma/2)&lt;1) { neg_loglik &lt;- -res_filter$loglik } else { neg_loglik &lt;- Inf } return(neg_loglik) } ## MLE arma11tgarch11_mle &lt;- function(y, params) { # nlminb function optimizing parameters fit &lt;- nlminb(start = params, objective = arma11tgarch11_objective, y = y, lower = c(-1, -0.999, -0.999, -1, 0.01, 0.01, 0.001), upper = c( 1, 0.999, 0.999, 1, 0.9, 0.9, 0.9)) ## output names(fit$par) &lt;- c(&quot;c&quot;, &quot;phi&quot;, &quot;theta&quot;, &quot;omega&quot;, &quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;) fit$par } startparams &lt;- c(0, 0.9, 0, 0.1, 0.1, 0.8, 0.01) mle &lt;- arma11tgarch11_mle(y, startparams) tab &lt;- cbind(MLE = mle, true = c(c, phi, theta, omega, alpha, beta, gamma)) row.names(tab) &lt;- c(&quot;c&quot;, &quot;phi&quot;, &quot;theta&quot;, &quot;omega&quot;, &quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;) round(tab, 3) ## MLE true ## c 0.001 0.00 ## phi 0.831 0.85 ## theta -0.119 -0.10 ## omega 0.001 0.01 ## alpha 0.028 0.10 ## beta 0.736 0.85 ## gamma 0.009 0.05 7.2 Modeling the S&amp;P 500 volatility We now show an application of the ARMA(1,1)-TGARCH(1,1) model to the S&amp;P 500 historical data. ## Load data sp500 &lt;- read.csv(&quot;../data/sp500.csv&quot;) sp500 &lt;- ts(sp500$adjusted_close[nrow(sp500):1], start = c(1999, 11, 1), freq = 365) d &lt;- diff(log(sp500))*252 plot.ts(d, main = &quot;S&amp;P 500 annualized growth rates&quot;) ## Compute MLE mle_sp500 &lt;- arma11tgarch11_mle(d, startparams) mle_sp500 ## c phi theta omega alpha beta ## 0.03314379 0.49055508 -0.53153704 0.16230434 0.01000000 0.87320296 ## gamma ## 0.19467830 ## plot fitted values filter_sp500 &lt;- arma11tgarch11_filter(d, mle_sp500) eps &lt;- filter_sp500$eps sig2 &lt;- filter_sp500$sig2 z &lt;- filter_sp500$z c &lt;- mle_sp500[1] phi &lt;- mle_sp500[2] theta &lt;- mle_sp500[3] omega &lt;- mle_sp500[4] alpha &lt;- mle_sp500[5] beta &lt;- mle_sp500[6] gamma &lt;- mle_sp500[7] t_max &lt;- length(d) fitted_sp500 &lt;- c + phi*d + theta*eps upper_sp500 &lt;- fitted_sp500 + 1.96*sqrt(sig2) lower_sp500 &lt;- fitted_sp500 - 1.96*sqrt(sig2) plot.ts(d, main = &quot;S&amp;P 500 annualized growth rates&quot;) lines(fitted_sp500, col = &quot;steelblue&quot;) lines(lower_sp500, col = &quot;tomato&quot;) lines(upper_sp500, col = &quot;tomato&quot;) text(x = 2009, y = 30, labels = paste0(&quot;Observations outside CI: &quot;, round(mean((d &gt; upper_sp500) | (d &lt; lower_sp500)),4)*100, &quot;%&quot;)) 7.3 Exercises Exercise 1 (h-step ahead volatility forecast of the GARCH(1,1)) Consider the GARCH(1,1) model \\[ \\begin{aligned} r_t &amp;= \\sigma^2_t z_t \\\\[1ex] \\sigma^2_t &amp;= \\omega + \\alpha r_{t-1}^2 + \\beta \\sigma^2_{t-1} \\end{aligned} \\] Show that \\[ \\mathbb{E}[\\sigma^2_{t+h} | r_t, \\sigma_t] = \\begin{cases} \\omega + \\alpha r_{t}^2 + \\beta \\sigma^2_t &amp; \\qquad \\text{if} \\quad h=1 \\\\ \\omega \\frac{1-(\\alpha+\\beta)^{h-1}}{1-\\alpha-\\beta} + (\\alpha+\\beta)^{h-1} \\ \\mathbb{E}[\\sigma^2_{t+1} | r_t, \\sigma_t] &amp; \\qquad \\text{if} \\quad h&gt;1 \\end{cases} \\] Exercise 2 (Log-likelihood of the ARMA(p,q)-GARCH(r,s) model) Consider the following specification of an ARMA model with conditionally-heteroskedastic innovations: \\[ \\begin{aligned} y_t &amp;= c + \\phi_1 y_{t-1} + \\dots + \\phi_p y_{t-p} + \\theta_1 \\varepsilon_{t-1} + \\dots + \\theta_q \\varepsilon_{t-q} + \\varepsilon_t \\\\ \\varepsilon_t &amp;= \\sigma_t z_t \\\\ \\sigma^2_t &amp;= \\omega + \\alpha_1 y_{t-1}^2 + \\dots + \\alpha_r y_{t-r}^2 + \\beta_1 \\sigma^2_{t-1} + \\dots + \\beta_s \\sigma^2_{t-s} \\end{aligned} \\] Derive the log-likelihood of the model under the assumption that \\(z_t \\sim \\mathcal{N}(0, 1)\\). Provide also the filtering procedure used to estimate the latent variables \\(\\varepsilon_t\\) and \\(\\sigma_t\\). Exercise 3 (Log-likelihood of the ARMA(1,1)-TGARCH(1,1) model) Consider the following specification of an ARMA model with asymmetric conditionally-heteroskedastic innovations: \\[ \\begin{aligned} y_t &amp;= c + \\phi y_{t-1} + \\theta \\varepsilon_{t-1} + \\varepsilon_t \\\\ \\varepsilon_t &amp;= \\sigma_t z_t \\\\ \\sigma^2_t &amp;= \\omega + \\alpha y_{t-1}^2 + \\beta \\sigma^2_{t-1} + \\gamma y_{t-1}^2 \\mathbb{1}_{y_{t-1}&lt;0} \\end{aligned} \\] Derive the log-likelihood of the model under the assumption that \\(z_t \\sim \\mathcal{N}(0, 1)\\). Provide also the filtering procedure used to estimate the latent variables \\(\\varepsilon_t\\) and \\(\\sigma_t\\). "],["session08.html", "Session 8 Value-at-Risk and correlation modelling 8.1 Exercises", " Session 8 Value-at-Risk and correlation modelling 8.1 Exercises Exercise 1 (Value-at-Risk using GARCH models) Consider the problem of estimating the Value-at-Risk \\(-\\text{VaR}_t^p = Q_p(r_t | I_{t-1})\\) using a GARCH model \\(r_t = \\sigma_t z_t\\) and \\(\\sigma_t\\) known given the information set \\(I_{t-1}\\). Discuss how to estimate \\(Q_p(r_t | I_{t-1})\\) under the assumption that \\(z_t \\sim \\mathcal{N}(0,1)\\). How could you estimate the VaR without assuming the true distribution of \\(z_t\\)? How would you evaluate the VaR forecasts out of sample? Discuss how to apply the unconditional coverage test and the dynamic quantile test in this context. Exercise 2 (Covariance matrix of factor ARCH model) Consider the factor ARCH model \\[ \\begin{aligned} r_{it} &amp;= \\lambda_i r_{mt} + \\sigma_{it} z_{it}, &amp;\\quad z_{it} \\sim \\mathcal{D}(0,1) \\\\ r_{it} &amp;= \\sigma_{mt} z_{mt}, &amp;\\quad z_{mt} \\sim \\mathcal{D}(0,1) \\end{aligned} \\] where \\(r_{mt}\\) is the market return, \\(\\sigma_{mt}\\) is the market volatility and \\(\\lambda_i\\) is the loading of stock \\(i\\) on the market return. Assume that \\(\\text{cov}(z_{mt}, z_{it}) = 0\\) (the common shock and the idiosyncratic shock are uncorrelated), \\(\\text{cov}(z_{it}, z_{jt}) = 0\\) (the idiosyncratic shocks are uncorrelated) and \\(\\sigma_{mt}, \\sigma_{it}\\) are known given \\(I_{t-1}\\) (ARCH/GARCH dynamics). Derive the covariance matrix of the returns. In particular, show that: \\(\\text{Var}_{t-1}(r_{it}) = \\lambda_i^2 \\sigma^2_{mt} + \\sigma_{it}^2\\) \\(\\text{cov}_{t-1}(r_{it}, r_{jt}) = \\lambda_i \\lambda_j \\sigma_{mt}^2\\) "],["session09.html", "Session 9 Additional exercises 9.1 Exercises", " Session 9 Additional exercises 9.1 Exercises Exercise 1 Describe the behaviour of the ACF and PACF for ARMA models. How does the behaviour of the ACF/PACF help identifying an ARMA model? Exercise 2 Show that the following AR(2) model is stationary: \\[ y_t = 0.6 y_{t-1} - 0.08 y_{t-2} + \\varepsilon_t \\] Exercise 3 Show that the kurtosis of an ARCH(1,1) process is \\[ \\mathbb{E}[\\sigma_t^4] = \\sigma^4(1+\\alpha^2) - \\alpha \\mu_4 \\sigma^4 \\frac{1-\\alpha^2}{1-\\alpha^2 \\mu_4} \\] Exercise 4 Consider the process \\[ y_t = \\delta + \\sum_{s=1}^t \\varepsilon_s + x_t \\] where \\(\\varepsilon_t\\) is i.i.d. and \\(x_t\\) is a covariance-stationary process with \\(\\mathbb{E}[x_t] = 0\\). Show that \\(y_t\\) is an \\(I(1)\\) process. Exercise 5 Let \\(x_t\\) be a covariance-stationary process. Show that the first difference \\(\\Delta x_t\\) is also covariance stationary. Exercise 6 Derive the optimal \\(h\\)-step ahead forecast for the conditional mean using an AR(1) model. Exercise 7 Derive the MA(\\(\\infty\\)) representation of an AR(1) model. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
